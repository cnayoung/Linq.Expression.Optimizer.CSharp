# Linq.Expression.Optimizer.CSharp
A C# port of Thorium's F# optimizer code.

Tuomas Hietanen's code is written in F# and can be found here: https://github.com/Thorium/Linq.Expression.Optimizer.  The code provides a lightweight optimizer for System.Linq.Expression expressions. It supports basic Boolean algebra and reductions and constant and tuple/anonymous type eliminations. It is designed for side-effect free Expressions. There are no compilation-subjective optimizations. The code is meant to be used with expressions that are not compiled but transferred to other domains.

For further information, please see the documentation and tutorial available on the Thorium site.

I needed a starting point for Linq expression optimisation for a project I'm working on, and Tuomas' code meets that need. However, the project uses C# and I didn't want part of the code base to be in a different language. So, as a starting point, I ported the F# code into C# 10. It's a direct port and is keeps as close as possible to the original.  I've even kept the comments!  Unlike the F# version, I've only provided support for .NET 6.0.  Of course, C# is not a functional language, and you have to hold the compiler's hand a little more tightly than F#.  Pattern matching isn't identical, and C# has its own 'built-in' alternative to Option. However, as a testament to how far C# has evolved over the years, there is broadly a one-to-one correspondence with the F# code.

The F# code is public domain, so I have licenced this version of the code on the same terms.  I have not provided a nuget package because I can't see the point in having two packages with identical function.

I've provided a set of tests based on Tuomas' tests.  There are some issues, though. One of the tests (for query 11) is broken in the F# version, and was similarly broken here, but I've amended the test to pass. The original code uses F# query expressions. For the C# version, I've used C# query syntax which can generate slightly different expressions and which is automatically optimised in slightly different ways by the Roslyn compiler. However, the biggest problem is that for 8 of the 16 queries, the F# query expressions generate Linq expression code to represent a SelectEnumerableIterator. This class is used to perform lazy evaluation of an underlying Linq query when the code iterates through the results.  Unfortunately, this hides the underlying Linq expression from the optimiser, and also distorts the benchmark figures because a) the visitor has no optimisation work to do and b) executing the SelectEnumerableIterator expression takes no appreciable time.  So, when you run the benchmark tests for the C# code, you will find they take twice as long.  This is because the C# tests do twice the work, and not because the C# code runs half as fast!  In fact, if you eliminate the problem tests, the benchmark figures are nearly identical, as you would probably expect.
